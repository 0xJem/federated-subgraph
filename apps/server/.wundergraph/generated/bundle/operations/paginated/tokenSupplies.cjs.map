{
  "version": 3,
  "sources": ["../../../../operations/paginated/tokenSupplies.ts", "../../../wundergraph.factory.ts"],
  "sourcesContent": ["import { addDays } from 'date-fns';\nimport { TokenSuppliesResponseData } from '../../generated/models';\nimport { createOperation, z } from '../../generated/wundergraph.factory';\n\n/**\n * The Graph Protocol's server has a limit of 1000 records per query (per endpoint).\n * \n * There are on average 50 records per day (for Ethereum, which has the most records),\n * so we can query 10 days at a time to stay under the limit.\n */\nconst OFFSET_DAYS = 10;\n\nconst getISO8601DateString = (date: Date): string => {\n  return date.toISOString().split(\"T\")[0];\n}\n\nconst getNextEndDate = (currentDate: Date | null): Date => {\n  // If currentDate is null (first time being used), set the end date as tomorrow\n  const tomorrowDate: Date = addDays(new Date(), 1);\n  tomorrowDate.setUTCHours(0, 0, 0, 0);\n\n  return currentDate === null ? tomorrowDate : currentDate;\n}\n\nconst getOffsetDays = (dateOffset?: number): number => {\n  if (!dateOffset) {\n    return OFFSET_DAYS;\n  }\n\n  return dateOffset;\n}\n\nconst getNextStartDate = (offsetDays: number, finalStartDate: Date, currentDate: Date | null): Date => {\n  const newEndDate: Date = getNextEndDate(currentDate);\n\n  // Subtract OFFSET_DAYS from the end date to get the new start date\n  const newStartDate: Date = addDays(newEndDate, -offsetDays);\n\n  // If the new start date is before the final start date, use the final start date\n  return newStartDate.getTime() < finalStartDate.getTime() ? finalStartDate : newStartDate;\n};\n\n/**\n * This custom query will return a flat array containing TokenSupply objects from\n * across all endpoints.\n * \n * It also handles pagination to work around the Graph Protocol's 1000 record limit.\n */\nexport default createOperation.query({\n  input: z.object({\n    startDate: z.string({ description: \"The start date in the YYYY-MM-DD format.\" }),\n    dateOffset: z.number({ description: \"The number of days to paginate by. Reduce the value if data is missing.\" }).optional(),\n    pageSize: z.number({ description: \"The number of records per page. Increase the value if data is missing.\" }).optional(),\n  }),\n  handler: async (ctx) => {\n    console.log(`Commencing paginated query for TokenSupply`);\n    console.log(`Input: ${JSON.stringify(ctx.input)}`);\n    const finalStartDate: Date = new Date(ctx.input.startDate);\n    console.log(`finalStartDate: ${finalStartDate.toISOString()}`);\n    if (isNaN(finalStartDate.getTime())) {\n      throw new Error(`startDate should be in the YYYY-MM-DD format.`);\n    }\n\n    const offsetDays: number = getOffsetDays(ctx.input.dateOffset);\n\n    // Combine across pages and endpoints\n    const combinedTokenSupplies: TokenSuppliesResponseData[\"treasuryEthereum_tokenSupplies\"] = [];\n\n    let currentStartDate: Date = getNextStartDate(offsetDays, finalStartDate, null);\n    let currentEndDate: Date = getNextEndDate(null);\n\n    while (currentStartDate.getTime() > finalStartDate.getTime()) {\n      console.log(`Querying for ${getISO8601DateString(currentStartDate)} to ${getISO8601DateString(currentEndDate)}`);\n      const queryResult = await ctx.operations.query({\n        operationName: \"tokenSupplies\",\n        input: {\n          startDate: getISO8601DateString(currentStartDate),\n          endDate: getISO8601DateString(currentEndDate),\n        },\n      });\n\n      if (queryResult.data) {\n        console.log(`Got ${queryResult.data.treasuryArbitrum_tokenSupplies.length} Arbitrum records.`);\n        combinedTokenSupplies.push(...queryResult.data.treasuryArbitrum_tokenSupplies);\n        console.log(`Got ${queryResult.data.treasuryEthereum_tokenSupplies.length} Ethereum records.`);\n        combinedTokenSupplies.push(...queryResult.data.treasuryEthereum_tokenSupplies);\n        console.log(`Got ${queryResult.data.treasuryFantom_tokenSupplies.length} Fantom records.`);\n        combinedTokenSupplies.push(...queryResult.data.treasuryFantom_tokenSupplies);\n        console.log(`Got ${queryResult.data.treasuryPolygon_tokenSupplies.length} Polygon records.`);\n        combinedTokenSupplies.push(...queryResult.data.treasuryPolygon_tokenSupplies);\n      }\n\n      currentEndDate = currentStartDate;\n      currentStartDate = getNextStartDate(offsetDays, finalStartDate, currentEndDate);\n    }\n\n    console.log(`Returning ${combinedTokenSupplies.length} records.`);\n    return combinedTokenSupplies;\n  },\n});\n", "// Code generated by wunderctl. DO NOT EDIT.\n\nimport type { InternalClient } from \"./wundergraph.internal.client\";\nimport { InternalOperationsClient } from \"./wundergraph.internal.operations.client\";\nimport type { Role } from \"./wundergraph.server\";\nimport type { CustomClaims } from \"./claims\";\nimport { createOperationFactory } from \"@wundergraph/sdk/operations\";\n\nexport {z, AuthorizationError} from \"@wundergraph/sdk/operations\";\nexport const createOperation = createOperationFactory<InternalClient, Role, CustomClaims, InternalOperationsClient>();\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBAAwB;;;ACMxB,wBAAuC;AAEvC,IAAAA,qBAAoC;AAC7B,IAAM,sBAAkB,0CAAqF;;;ADCpH,IAAM,cAAc;AAEpB,IAAM,uBAAuB,CAAC,SAAuB;AACnD,SAAO,KAAK,YAAY,EAAE,MAAM,GAAG,EAAE;AACvC;AAEA,IAAM,iBAAiB,CAAC,gBAAmC;AAEzD,QAAM,mBAAqB,yBAAQ,IAAI,KAAK,GAAG,CAAC;AAChD,eAAa,YAAY,GAAG,GAAG,GAAG,CAAC;AAEnC,SAAO,gBAAgB,OAAO,eAAe;AAC/C;AAEA,IAAM,gBAAgB,CAAC,eAAgC;AACrD,MAAI,CAAC,YAAY;AACf,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAEA,IAAM,mBAAmB,CAAC,YAAoB,gBAAsB,gBAAmC;AACrG,QAAM,aAAmB,eAAe,WAAW;AAGnD,QAAM,mBAAqB,yBAAQ,YAAY,CAAC,UAAU;AAG1D,SAAO,aAAa,QAAQ,IAAI,eAAe,QAAQ,IAAI,iBAAiB;AAC9E;AAQA,IAAO,wBAAQ,gBAAgB,MAAM;AAAA,EACnC,OAAO,qBAAE,OAAO;AAAA,IACd,WAAW,qBAAE,OAAO,EAAE,aAAa,2CAA2C,CAAC;AAAA,IAC/E,YAAY,qBAAE,OAAO,EAAE,aAAa,0EAA0E,CAAC,EAAE,SAAS;AAAA,IAC1H,UAAU,qBAAE,OAAO,EAAE,aAAa,yEAAyE,CAAC,EAAE,SAAS;AAAA,EACzH,CAAC;AAAA,EACD,SAAS,OAAO,QAAQ;AACtB,YAAQ,IAAI,4CAA4C;AACxD,YAAQ,IAAI,UAAU,KAAK,UAAU,IAAI,KAAK,GAAG;AACjD,UAAM,iBAAuB,IAAI,KAAK,IAAI,MAAM,SAAS;AACzD,YAAQ,IAAI,mBAAmB,eAAe,YAAY,GAAG;AAC7D,QAAI,MAAM,eAAe,QAAQ,CAAC,GAAG;AACnC,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAEA,UAAM,aAAqB,cAAc,IAAI,MAAM,UAAU;AAG7D,UAAM,wBAAqF,CAAC;AAE5F,QAAI,mBAAyB,iBAAiB,YAAY,gBAAgB,IAAI;AAC9E,QAAI,iBAAuB,eAAe,IAAI;AAE9C,WAAO,iBAAiB,QAAQ,IAAI,eAAe,QAAQ,GAAG;AAC5D,cAAQ,IAAI,gBAAgB,qBAAqB,gBAAgB,QAAQ,qBAAqB,cAAc,GAAG;AAC/G,YAAM,cAAc,MAAM,IAAI,WAAW,MAAM;AAAA,QAC7C,eAAe;AAAA,QACf,OAAO;AAAA,UACL,WAAW,qBAAqB,gBAAgB;AAAA,UAChD,SAAS,qBAAqB,cAAc;AAAA,QAC9C;AAAA,MACF,CAAC;AAED,UAAI,YAAY,MAAM;AACpB,gBAAQ,IAAI,OAAO,YAAY,KAAK,+BAA+B,0BAA0B;AAC7F,8BAAsB,KAAK,GAAG,YAAY,KAAK,8BAA8B;AAC7E,gBAAQ,IAAI,OAAO,YAAY,KAAK,+BAA+B,0BAA0B;AAC7F,8BAAsB,KAAK,GAAG,YAAY,KAAK,8BAA8B;AAC7E,gBAAQ,IAAI,OAAO,YAAY,KAAK,6BAA6B,wBAAwB;AACzF,8BAAsB,KAAK,GAAG,YAAY,KAAK,4BAA4B;AAC3E,gBAAQ,IAAI,OAAO,YAAY,KAAK,8BAA8B,yBAAyB;AAC3F,8BAAsB,KAAK,GAAG,YAAY,KAAK,6BAA6B;AAAA,MAC9E;AAEA,uBAAiB;AACjB,yBAAmB,iBAAiB,YAAY,gBAAgB,cAAc;AAAA,IAChF;AAEA,YAAQ,IAAI,aAAa,sBAAsB,iBAAiB;AAChE,WAAO;AAAA,EACT;AACF,CAAC;",
  "names": ["import_operations"]
}
